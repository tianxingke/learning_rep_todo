常用配置：
显示GC日志：http://blog.csdn.net/zsy112371/article/details/44981923

------------------------------------------------------------------------------------------------------------

一、Java虚拟机运行时数据区
1.结构图片http://img.blog.csdn.net/20160801164042333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
2.运行时数据区组成：
	a).程序计数器：可以看作是当前线程所执行的字节码的行号指示器。通过改变这个计数器的值来选取下条要执行的字节码指令。分支、循环、异常等都依赖计数器。
			每个线程都有各自的计数器，互不影响，为私有内存。
			如果线程正在执行的是Java方法，则此计数器记录的是正在执行的字节码指令地址，如果是Native方法则计数器值为空。
			此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
	
	b).java虚拟机栈：Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
	局部变量表存放了编译期可知的各种基本数据类型（8种基本类型）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。
	这个区域有两种异常状态：1）如果线程请求的栈深度大雨虚拟机所允许的深度，将抛出StackOverflowError异常。2）如果动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
	
	c).本地方法栈：本地方法栈为虚拟机使用到的Native方法（字节码）服务。与虚拟机栈一样，也会抛出StackOverflowError和OutOfMemoryError异常。
	
	d).Java堆：java堆是虚拟机内存中最大的一块。是被所有的线程共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放（几乎所有）对象实例。
	java堆又被称为GC堆。由于现在收集器基本都是采用分代收集算法，所以java堆中可以分为新生代和老年代。从内存分配的角度来看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区（TLAB）。
	java堆可以处于物理上不连续的内存空间。可扩展（通过-Xmx和-Xms控制）。
	如果堆中没有内存完成实例分配，并且也无法再扩展时，抛出OutOfMemoryError。

	e).方法区：是线程共享的，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。别名Non-Heap（非堆）。很多人把方法区称为“永久代”（Permanent Generation），（-XX：MaxPermSize控制上限），正逐渐废弃。JDK1.7的HotSpot中已经把原本放在永久代中的字符串常量池移出。
	当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
	
	f):运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号作用，这部分内容将在类加载后进入方法区的运行时常量池中存放。同方法区管理，会抛出OutOfMemoryError异常。

	g):直接内存：直接内存并不是虚拟机运行时数据区的一部分。会抛出OutOfMemoryError异常。不受java堆大小限制。
	
3.溢出
	a):java堆溢出
		通过参数 -XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。 
		如果出现堆区域的异常，一般的手段是通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。如果是内存泄漏。。。。，如果不存在内存泄漏。。。。（第52页）。

	b):虚拟机栈和本地方法栈溢出
		-Xss
		可以使用减少最大堆和减少栈容量的方式换取更多的线程，以这种“减少内存”的方式来解决内存溢出。
		每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。

	c):方法区和常量池溢出
		intern（）方法的问题（第57页）不太明白
		String str1 = new StringBuilder("计算机").append("软件").toString();
		System.out.println(str1.intern() == str1);				//true	jdk1.7
		String str2 = new StringBuilder("ja").append("va").toString();
		System.out.println(str2.intern() == str2);				//false	jdk1.7

	d):本机直接内存溢出
		DirectMemory 容量可以通过 -XX:MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值（-Xmx指定）一样。
		由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或者间接使用了NIO，那就可以考虑检测一下是不是这方面的原因。


二、垃圾收集器与内存分配策略（第三章）
1.在java虚拟机中是通过 可达性分析 来判定对象是否存活的。
	不可达的对象要至少经历两次标记过程，判定GC Roots时第一次进行标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。不建议在代码中使用此方法，用try更好。

2.JDK1.2之后，java对引用的概念进行了扩充，由强度依次减弱，将引用分为强引用、软引用、弱引用、虚引用4种。

3.方法区（永久代）回收包括两部分：废弃常量和无用的类。

4.垃圾收集算法
	1).标记-清除算法:标记、清除效率不高，空间上会产生碎片。
	
	2).复制算法：将内存分成两份，当其中一份内存用完了时就将还存活的对象复制到另一块上（只要移动堆顶指针，按顺序分配内存即可），然后将另一块直接整个回收。折半内存，浪费内存。现在的商业虚拟机都采用这种方式回收新生代。新生代中分出一块较大的Eden空间和两块较小的Survivor空间，每次将Eden和其中一块Survivor空间还存活的对象复制到另一块Survivor空间。最后清理Eden和Survivor。如果Survivor的空间不够，这些对象直接通过分配担保进入老年代。
	当存活对象较多时，效率降低。更关键的，不想浪费50%空间就需额外空间进行分配担保。
	
	3).标记-整理算法：老年代中，标记完成后让所有存活的对象都想一端移动，然后直接清理端边界以外的内存。
	
	4).分代收集算法：当前商业虚拟机的垃圾收集都采用“分代收集”算法。根据对象存活周期的不同将内存分为几块。一般是把java堆分为新生代和老年代，然后各代采用最适当的算法。在新生代用复制算法，老年代采用“标记-清理”或者“标记-整理”算法。 

5.垃圾收集器
	所有收集器图3-5.
6.
























































































